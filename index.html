<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>共勉</title>
    <style>
        .main {
            /*display: none;*/
        }

    </style>
</head>
<body>
<div>
    <h1 class="h1">HTML&CSS</h1>
    <div class="main">

        <div class="yi">
            <h3>1.对Web标准的理解</h3>
            <ul>
                <li>web标准规范要求，书写必须闭合、标签小写、不乱嵌套，可以提高搜索机器人对网页内容的搜索几率。</li>
                <li>
                    使用外链css和js脚本，从而达到结构与行为、结构与表现的分离，提高页面的渲染速度，能更快的显示页面的内容。
                </li>
                <li>样式与标签的分离，更合理的语义化标签，是内容能被更多的用户访问、内容被更广泛的设备所访问、更少的代码和组件，从而降低维护成本。</li>
                <li>
                    不需要变动页面内容，就可以提供打印版本而不需要复制内容，提高网站的易用性
                </li>
            </ul>
        </div>
        <div class="er">
            <h3>2.Doctype? 严格模式与混杂模式-如何触发这两种模式，区分它们有何意义? </h3>
            <ol>
                <li>用于声明文档使用那种规范（html/Xhtml）一般为 严格 过度 基于框架的html文档
                </li>
                <li>加入XMl声明可触发，解析方式更改为IE5.5 拥有IE5.5的bug</li>
            </ol>
        </div>
        <div class="san">
            <h3>3.浏览器内核的差异</h3>
            <ul>
                <li><h5>1.Trident</h5>
                    IE浏览器使用的内核 Trident是一款开放的内核，其接口内核设计的相当成熟。市场占有率高。
                    <ul>
                        <li>1.Trident内核曾经几乎与W3C标准脱节（2005年）</li>
                        <li>2.Trident内核的大量 Bug等安全性问题没有得到及时解决</li>
                    </ul>
                </li>
                <li>
                    <h5>2.Gecko</h5>
                    FireFox (火狐浏览器) 特点是开源内核，代码完全公开，可开发程度很高。是一个跨平台内核，可以在Windows、 BSD、Linux和Mac OS X中使用
                </li>
                <li>
                    <h5>3.Presto</h5>
                    Opera采用的内核 特点是渲染速度的优化达到了极致，也是目前公认网页浏览速度最快的浏览器内核，然而代价是牺牲了网页的兼容性。
                    实际上这是一个动态内核与前面几个最大的区别就在脚本处理上，Presto有着天生的优势，页面的全部或者部分都能够在回应脚本事件时等情况下被重新解析。
                </li>
                <li>
                    <h5>4.Webkit</h5>
                    苹果公司自己的内核 Webkit是自由软件，同时开放源代码。在安全方面不受IE、Firefox的制约，所以Safari浏览器在国内还是很安全的。
                </li>
            </ul>
            <p> google的chrome也使用webkit作为内核。　
                WebKit 内核在手机上的应用也十分广泛，例如 Google 的手机 Gphone、 Apple 的 iPhone， Nokia’s Series 60 browser 等所使用的 Browser
                内核引擎，都是基于 WebKit。</p>
        </div>
        <div class="si">
            <h3>4.浏览器渲染原理</h3>
            <ol>
                <li>用户输入网址（假设是个html页面，并且是第一次访问），浏览器向服务器发出请求，服务器返回html文件</li>
                <li>浏览器开始载入html代码，发现
                    <head>标签内有一个
                        <link>
                        标签引用外部CSS文件
                </li>
                <li>浏览器又发出CSS文件的请求，服务器返回这个CSS文件</li>
                <li>浏览器继续载入html中
                    <body>部分的代码，并且CSS文件已经拿到手了，可以开始渲染页面了
                </li>
                <li>浏览器在代码中发现一个<img>标签引用了一张图片，向服务器发出请求。此时浏览器不会等到图片下载完，而是继续渲染后面的代码</li>
                <li>服务器返回图片文件，由于图片占用了一定面积，影响了后面段落的排布，因此浏览器需要回过头来重新渲染这部分代码</li>
                <li>浏览器发现了一个包含一行Javascript代码的script标签，赶快运行它</li>
                <li>Javascript脚本执行了这条语句，它命令浏览器隐藏掉代码中的某个（style.display=”none”）。杯具啊，突然就少了这么一个元素，浏览器不得不重新渲染这部分代码</li>
                <li>终于等到了 /html 的到来，浏览器泪流满面……</li>
                <li>等等，还没完，用户点了一下界面中的“换肤”按钮，Javascript让浏览器换了一下 link 标签的CSS路径</li>
                <li>浏览器召集了在座的各位
                    span ul li们，“大伙儿收拾收拾行李，咱得重新来过……”，浏览器向服务器请求了新的CSS文件，重新渲染页面
                </li>
            </ol>
        </div>
        <div class="wu">
            <h3>5.CSS3中各个浏览器内核兼容的设置</h3>
            <ol>
                <li>-moz-：代表FireFox浏览器私有属性</li>
                <li>-ms-：代表IE浏览器私有属性</li>
                <li>-webkit-：代表safari、chrome浏览器私有属性</li>
                <li>-o-：代表opera浏览器私有属性</li>
            </ol>
        </div>
        <div class="liu">
            <h3>6.xhtml和html有什么区别?</h3>
            <p>HTML是一种基本的WEB网页设计语言，XHTML是一个基于XML的置标语言.</p>
            <div>
                <ol>
                    <li>XHTML 元素必须被正确地嵌套。</li>
                    <li>XHTML 元素必须被关闭。</li>
                    <li>标签名必须用小写字母。</li>
                    <li>XHTML 文档必须拥有根元素。</li>
                </ol>
            </div>
        </div>
        <div class="qi">
            <h3>7.什么是CSS hack?</h3>
            <p>
                由于不同厂商的流览器或某浏览器的不同版本（如IE6-IE11,Firefox/Safari/Opera/Chrome等），对CSS的支持、解析不一样，导致在不同浏览器的环境中呈现出不一致的页面展现效果。这时，我们为了获得统一的页面效果，就需要针对不同的浏览器或不同版本写特定的CSS样式，我们把这个针对不同的浏览器/不同版本写相应的CSS
                code的过程，叫做CSS hack!</p>
            <div>
                <h5><b>CSS hack方式一：条件注释语法 (这种方式是IE浏览器专有的Hack方式)</b></h5>
                <ol>
                    <li>只在IE下生效
                        <xmp><!--[if IE]> 这段文字只在IE浏览器显示<![endif]--></xmp>
                    </li>
                    <li>
                        只在IE6下生效
                        <xmp><!--[if IE 6]>这段文字只在IE6浏览器显示<![endif]--></xmp>
                    </li>
                    <li>
                        只在IE6以上版本生效
                        <xmp><!--[if gte IE 6]> 这段文字只在IE6以上(包括)版本IE浏览器显示<![endif]--></xmp>
                    </li>
                    <li>
                        只在IE8上不生效
                        <xmp><!--[if ! IE 8]>这段文字在非IE8浏览器显示<![endif]--></xmp>
                    </li>
                    <li>
                        非IE浏览器生效
                        <xmp><!--[if !IE]>这段文字只在非IE浏览器显示<![endif]--></xmp>
                    </li>
                </ol>
            </div>
            <div>
                <h5><b>CSS hack方式二：类内属性前缀法</b></h5>
                <p>属性前缀法是在CSS样式属性名前加上一些只有特定浏览器才能识别的hack前缀，以达到预期的页面展现效果。(对照表自己看吧)</p>
            </div>
            <div>
                <h5>CSS hack方式三：选择器前缀法</h5>
                <p>选择器前缀法是针对一些页面表现不一致或者需要特殊对待的浏览器，在CSS选择器前加上一些只有某些特定浏览器才能识别的前缀进行hack.</p>
                <ol>
                    <p>目前最常见的是</p>
                    <li>*html *前缀只对IE6生效</li>
                    <li>*+html *+前缀只对IE7生效</li>
                    <li>@media screen\9{...}只对IE6/7生效</li>
                    <li>@media \0screen {body { background: red; }}只对IE8有效</li>
                    <li>@media \0screen\,screen\9{body { background: blue; }}只对IE6/7/8有效</li>
                    <li>@media screen\0 {body { background: green; }} 只对IE8/9/10有效</li>
                    <li>@media screen and (min-width:0\0) {body { background: gray; }} 只对IE9/10有效</li>
                    <li>@media screen and (-ms-high-contrast: active), (-ms-high-contrast: none) {body { background:
                        orange; }} 只对IE10有效
                    </li>
                </ol>
            </div>
        </div>
        <div class="ba">
            <h3>8.清除浮动的几种方式，各自的优缺点</h3>
            <ol>
                <li>使用空标签清除浮动 clear:both（理论上能清楚任何标签，，，增加无意义的标签）</li>
                <li>使用overflow:auto（空标签元素清除浮动而不得不增加无意代码的弊端,,使用zoom:1用于兼容IE）</li>
                <li>使用afert伪元素清除浮动(用于非IE浏览器)</li>
            </ol>
        </div>
        <div class="jiu">
            <h3>9.CSS引入的方式有哪些? link和@import的区别是?</h3>
            <p>内联 内嵌 外链 导入</p>
            <p>区别 ：同时加载</p>
            <ol>
                <li>前者无兼容性，后者CSS2.1以下浏览器不支持</li>
                <li>Link 支持使用javascript改变样式，后者不可</li>
            </ol>
        </div>
        <div class="shi">
            <h3>10.</h3>
            <p>标签选择符 类选择符 id选择符</p>
            <ol>
                <li>
                    继承不如指定Id>class>标签选择
                </li>
                <li>后者优先级高</li>
            </ol>
        </div>
        <div class="shiyi">
            <h3>11.浏览器标准模式和怪异模式之间的区别是什么?</h3>
            <p>盒子模型 渲染模式的不同</p>
            <p>使用 window.top.document.compatMode 可显示为什么模式
            </p>
        </div>
        <div class="shier">
            <h3>12.前端页面有哪三层构成，分别是什么?作用是什么?</h3>
            <p>结构层 Html 表示层 CSS 行为层 js</p>
            <p>结构与行为、结构与表现的分离，提高页面的渲染速度</p>

        </div>
        <div class="shisan">
            <h3>13.标签上title与alt属性的区别是什么?</h3>
            <p>Alt 当图片不显示是 用文字代表</p>
            <p>Title 为该属性提供信息</p>

        </div>
    </div>

    <h1 class="h2">Javascript</h1>
    <div class="js">
        <div class="js1">
            <h3>1.js的组成？</h3>
            <ol>
                <li>ECMAScript规定了js中的规范</li>
                <li>BOM 浏览器对象模型  --  window（浏览器对象）</li>
                <li>DOM 文档对象模型 -- document（文档对象）</li>
            </ol>
        </div>
        <div class="js2">
            <h3>2.JS中的数据类型</h3>
            <ol>
                <li><b>基本数据类型：</b>
                    <ol>
                        <li>数字(number)
                           <ol>整数和浮点数、isNaN() => true不是一个数/false
                               <li>Number() => 数字/NaN</li>
                               <li>parseInt() => 取整</li>
                               <li>parseFloat() => 包含小数部分</li>

                           </ol>
                        </li>
                        <li>布尔(boolean)
                           <ul>
                               <li> <p>判断一个值是否为true和false的规律？</p>
                                   0  NaN  ""  null undefined这五个为false 其余都为true
                               </li>
                           </ul>
                        </li>
                        <li>字符串(string)
                        <ol>
                            <li>charAt(index) => 通过索引来获取字符（如果索引值超出了范围返回空字符串）</li>
                            <li> charCodeAt(index) => 返回对应ASCII表的编码</li>
                            <li>substr(n,m) => 从索引n开始截取m个</li>
                            <li>substring(n,m) => 从索引n开始到索引m-1</li>
                            <li>slice(n,m) => 支持负数索引</li>
                            <li>toUpperCase()</li>
                            <li>toLowerCase()</li>
                            <li>indexOf('a') => 字母a在字符串中出现的索引位置，出现返回对应的索引，否则返回-1</li>
                            <li>lastIndexOf('a')</li>
                            <li>当repalce方法的第二个参数是函数，那么是用这个函数执行结果(return)来替换第一个参数所匹配到的字符
                            <p>replace(old,function (){
                                return val;
                                });</p>
                            </li>
                            <li>split() => 把字符串按照参数拆分成数组  参数也可以是一个正则</li>
                            <li>match() // 正则</li>
                            <li>search() //查找</li>
                            <li>eval() 把字符串当作js表达式运行  去引号</li>
                        </ol></li>
                        <li>null</li>
                        <li>undefined</li>
                    </ol>
                </li>
                <li><b>引用数据类型：</b>
                    <ol>
                        <li>对象数据类型（object）：
                            <ol>
                                <li>Object （对象类）</li>
                                <li>Array（数组类）
                                <ol>
                                    <li>push():向数组的末尾增加新的内容</li>
                                    <li>pop():删除数组最后一项，返回删除项</li>
                                    <li>unshift():向数组开头增加一项，原数组改变,返回的是增加后数组的length</li>
                                    <li>shift():删除数组第一项，原数组改变，返回被删除项</li>
                                    <li>splice(n,m) 从索引n开始删除m个元素，原数组改变，返回被删除项。 splice(n,0,x)可增加删除</li>
                                    <li>slice(n,m)从原数组截取 从索引0开始到索引m处不包含m 原数组不变 返回新数组</li>
                                    <li>reverse() => 直接把原有数组倒序</li>
                                    <li>sort(function (a,b){return a-b})  => 都是在原有数组上排序</li>
                                    <li>ary1.concat(ary2) => 返回新数组  ary1.concat(5,'a',[6]) => 拼接的参数可以是任意</li>
                                    <li>join() => 把数组项拼接成字符串</li>
                                    <li> indexOf() 所查找的字符不存在则返回 -1</li>
                                    <li>lastIndexOf() => 最后出现的索引 没有则返回-1</li>
                                </ol>
                                </li>
                                <li>正则类（RegExp）
                                <ol>
                                    <li>new Date()</li>
                                    <li>getFullYear()</li>
                                    <li>getMonth()</li>
                                    <li>getDay()</li>
                                    <li>getHours()</li>
                                    <li> getMinutes()</li>
                                    <li>getSeconds()</li>
                                    <li> getMilliseconds()</li>
                                    <li> getTime() 距离1970年01月01日 8:00 ms</li>
                                </ol>
                                </li>
                                <li>Math（数学函数类）</li>
                                <li>Data（时间类）</li>
                                <li>String（字符串类）</li>
                                <li>Number（数字类）</li>
                            </ol>
                        </li>
                        <li>函数数据类型（function）</li>
                    </ol>
                </li>
            </ol>
        </div>
        <div class="js3">
            <h3>3.javascript的typeof返回哪些数据类型</h3>
            <b><p>Object number function boolean underfind</p></b>
        </div>
        <div class="js4">
            <h3>4.闭包</h3>
            <p><b>为什么要写闭包</b></p>
            <p> 当想要保护一个变量(num)或者函数(sum,reduce)不受外界干扰。那么我们把变量和函数放到一个函数中(把num和sum、reduce都放到fn这个函数中)。那么我们就完成了一个闭包写法。当这个函数(fn)执行的时候就形成了一个闭包。</p>
            <p><b>制造闭包: 把要保护的变量放到一个执行函数中就可以</b></p>
        </div>


    </div>

</div>




<div style="height: 5000px;">

</div>

<!--<script>-->
<!--//    let h1 = document.querySelector('.h1');-->
<!--//    let main = document.querySelector('.main');-->
<!--//-->
<!--//-->
<!--//    h1.onclick = function () {-->
<!--//        main.style.display = 'block';-->
<!--//    };-->


    <!--let ary = [100,1,4,2,3,4,6,7];-->
<!--//    ary.push(5);-->
<!--// let a=ary.pop();-->
<!--let a = ary.lastIndexOf(4)-->
<!--console.log(ary);-->

<!--console.log(a);-->
<!--</script>-->

</body>
</html>